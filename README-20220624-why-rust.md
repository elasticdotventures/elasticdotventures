I've been studying RUST 'hardcore' for the past few ~5 months (i.e. reviewing the entire compedium + backlog for the past ~10 years), and I am just now emerging from imposter syndrome.  I mostly understood everything the author was saying, I don't think I could write it - but I know what an AST is. 

I did not like the article, I do not think it highlights the benefits of RUST.  

Fwiw - I also _regularly_ write code in Typescript & Python, and I've written production & commercial code in at least a dozen other languages at different points in my career including Perl, C and C++. 

I've spent the past few months patching & sending PR's on others RUST code in preparation of writing my own app / next startup in RUST/WASM probably once it goes mainline in Linux.   Just learning how other people solve problems. 

RUST's has many advantageous benefits I can clearly recognize and it's hard to explain or summarize a single benefit individually.  

You shouldn't learn RUST because of a single abstract syntax tree, .. you should learn RUST to appreciate the majesty of the /forest/ eco-system.  

There are too many are really too many nuanced "cool-as-f*ck" behaviors & reasons to love RUST.  I doubt most people could really fully appreciate RUST until after they've spent a decade supporting apps in production in another language, and even then it's only "why RUST is better than <your language(s)>"   

RUST has the benefit of hindsight, cybersec was thought about on day zero.  It was born to be secure, and to prevent avoidable 'unforced-errors' mistakes that new programmers are inclined to make. 

RUST is therefore an intimdiating & highly technical, also it's a high release cadence language with a nightly/beta & stable build EVERY 6 WEEKS! 

RUST really oesn't have a lot of the stupid 'why does it work this way' learning curves (i.e. Python packages), instead RUST has a lot of 'it works this way because memory management is hard & race conditions are bad' sort of yikes-super-technical that can make it unapproachable for noobs. On the flip side, you don't need to know pointers, you can usually clone anything and some people advocate for this for noobs, but you won't be able to read the 'correctly written' optimized code until you break those bad habits later.  Pick your poison.

RUST also solves a lot of anti-pattern unforced-error issues with lifetimes & borrows which will be completely foreign to anybody coming from another language -- it's not like going from Spanish to Italian, it's like learning Mandarin or ASL - you simply won't be able to transfer a lot of your old patterns from other languages.  Learning new languages later in life is hard, drink more coffee.

BUT RUST is also totally worth it -- I mean, assuming you aren't imminently retiring from the industry and you are the type of person who likes to be a top-performing wizard in your domain of expertise.  I will explain why: 

The most ironic part of learning is RUST is it contains a compendium of not-anti-patterns that only a grey-beard's who have already spent weeks/months learning from their own mistakes, by tracing stuff can probably appreciate. (Like this article, this guy obviously has some PTSD from tracing a sporadic issue that stress aged him, that's why I read)

I love Rust for this reason alone - I simply can't get enough - it's a language that blocks mistakes.  Rusts solutions *to everything* are so elegant & well balanced.   There will a moment (for me it was Traits) when you might realize "counting & doing mental math in Mandarin is easier than English" and how magnitude-centric 'new math' for students is easier/better & but is based on Asian counting! (or how why metric is better, if perhaps you can more easily relate to that analogy). I think maybe the metric comparison is perhaps the most relatable for this audience -- if you prefer (F)arenheit over (C)elcius for science, and believe measures of Lbs/ounces are better than grams then stay away from Rust.  But for serious career developers - RUST is like adopting metric for scientists. 

Rust is not easy or cheap to learn, it is mental retooling & fresh start.  I can say RUST is optimized & done right (it wasn't always, and it still keeps getting better, so there is a case for waiting).  But I can say there is presently no better language humans have invented for systems engineering (except perhaps some experimental ones that are being built inside RUST, but those will probably ultimately be incorporated back into RUST itself in a future release .. such as Miri)

I can easily see Rust being my favorite all time lifetime language i.e. my epitaph inscription will be written to compile in Rust.   Rust was a BIG decision to dedicate more wetware synapses to yet another language, and I look forward to trying to forget the mental scars from C++. 

RUST a modern language built with hindsight.  Hindsight is empowering - for example Rust has an amazing package manager (cargo) built in.   The lack of null, combined with the Option<T> with either Result<Ok> or Error<E> uniformity and ability to handle errors with ease -- using an absurdly powerful match syntax .. it's like when I learned/mastered RegEx and suddenly an entire class of text processing problems 'just got easier' .. well Rust Match syntax is one of those.   The lifetime/borrow checking to avoids & catches the types of issues mentioned in the article.  The way macros reduce tedium, eliminate boilerplate, make it easy to build abstract DSL's into the code *if* you need/want to such as HTTP routing really slick (I can only relate to the first time webpack/transpilation in typescript 'clicked' in my brain).  But the way Traits, Generics, & macros can be applied in concert patterns, so when/if you can actually plan an application ground up these mechanisms _significantly_ reduce the code & especially the *TEST* footprint significantly and also make refactoring such as this example an absolute dream.  Again typescript *can* do this, but then you've got all the Javascript absurdium/baggage!  Rust by contract when writing 'safe' code it can't 'crash' (only Panic) and that means targeting future financial apps like smart-contracts in solidity is great.  But it also means if you ship code it will probably run the way you expect it to.  The intellisense lookups & rust-analyzer in vscode are really good *and* keep getting better.  The same language & libraries and testing for any type of critical IOT device from Arm, RISC-V, or smaller than arduino or smaller .. and of course Rust can import 100% of the C or C++ and usually speed up C & C++ development times once the initial Rust learning curve has been overcome.  I was taught in school 95% of the software cost is maintenance and Rust reduces the maintenance cost.  This is because the lack of 'surprise' runtime errors -- getting data back from the field, and the deterministic execution & without ever needing garbage collection (so the same routine always take the same number of microseconds, predictably, no surprise blocking/crash for-during GC).  The automatic tree-shaking during compilation to reduce attack surface and deployment times.  The ability to compile directly into WASM easily (a polyglot language) and target any architecture including micro-controllers while still testing locally and running in vscode with LLVM debugger/inspection.  WASM is the future no doubt especially for companies which give a shit about security & auditability, at least for most middleware & libraries, who needs/wants the overhead of rootless containers?  Clippy and rustc have the most intuitive and specific errors, often they can "auto-fix" issues.  The CFFI (C-foreign function interface) and bindgen is *too easy*, so it can compile code into nearly any other language (and that's without WASM).  The way workspaces & modules, libraries layout, and the mechanisms Rust uses to guarantees backward compatibility in the language across versions and gracefully deprecate features "never break things" but also periodically clean-up make RUST stand apart (for it's 6 week release cadence this is very first class inviolable, but also clippy can usually auto-'fix' 90% of the issues because it's REALLY amazingly aware of what the code is doing).  The way cargo is built to work so intuitively with git because it was built after git (unlike whatever language you're probably using).  The async support is also first class and strikes a really well thought out approach to thread-safety complexity when you need it - but when you don't then there is probably also an a single threaded way (but at the cost of complexity).  The execution performance rivals or exceeds C++ too but without the security headaches (no null) and that saves execution time and deployment costs by eliminating production issues which are again probably 95% of the cost of most applications -- but the WORST kind of issues, the kind th

This last aspect is why RUST will 'win' -- as startups adopt it they will unseat established companies with legacy code-bases as a way to gain operational efficiency.  A company building & deploying with RUST will have an order of magnitude less headaches and need an order of magnitude fewer engineers, plus refactoring in RUST is much easier thanks again to rustc.   If your competitor adopts RUST they will be using air-freight while you're delivering with a horse & wagon.  Not only that, the Rust engineers will probably be a higher caliber ..without being biased, it's not an easy language and so it's a good/quick discriminator for talent. 

I've covered a lot and honestly I've only shaved a few snow-cones off the iceberg of reasons to become a Rustacean.  Actually, I missed the biggest reason why RUST is awesome. 

The ABSOLUTE BEST part of RUST is the community which emphasizes inclusivity, simplification for 'next person' easy onboarding, and eager helpfulness friendly welcoming attidude.  Not only that, but the community really has some absolutely staggeringly brilliant persons -- the sort of next generation engineers who are not only crazy smart but also friendly, and the whole community echos this, it doesn't tolerate bad actors (the gruff non-approachable engineer who doesn't like observational behaviors & answering questions stick with C++).  
The hive-mind of the RUST community is something uncharacteristic, there is no equivalent in any other tech group I've seen (maybe web3/blockchain, but again A LOT of those people are also Rust folks!)

It's also worth mentioning there are probably at least a hundred to a thousand other reasons to love/try RUST. These are mine. 


